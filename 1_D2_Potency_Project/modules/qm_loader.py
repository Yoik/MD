import os
import numpy as np
import MDAnalysis as mda
import warnings
from .rdkit_matcher import RDKitMatcher
import MDAnalysis as mda
from rdkit import Chem
from rdkit.Chem import AllChem

# 屏蔽 MDAnalysis 的 PDB 写入警告
warnings.filterwarnings("ignore", category=UserWarning, module="MDAnalysis.coordinates.PDB")

from .cube_parser import CubeParser
# --- 辅助函数：寻找配体 ---
def find_ligand(u):
    """
    在 MDAnalysis Universe 中自动寻找配体残基
    策略：排除常见溶剂/离子，选择原子数最多的残基
    """
    # 尝试按残基名称选择
    p = u.select_atoms("resname LIG LIG1 LDP R5F DRG UNK MOL")
    if len(p) > 0: 
        return p.residues[0]
    
    # 如果找不到，按排除法筛选
    cands = [r for r in u.residues if r.resname not in [
        "TIP3", "SOL", "WAT", "SOD", "CLA", "POT", "ZN", "POPC", "POPE", "CHL", "CAL", "MG"
    ] and len(r.atoms) > 3]
    
    if not cands: 
        return None
    
    # 选原子数最多的（假设配体比离子大）
    cands.sort(key=lambda r: len(r.atoms), reverse=True)
    return cands[0]

def get_ref_data_from_pdb(pdb_file):
    """从参考 PDB 提取坐标和元素"""
    coords = []; elements = []; atom_lines = []
    try:
        with open(pdb_file, 'r') as f:
            for line in f:
                if line.startswith("ATOM") or line.startswith("HETATM"):
                    atom_name = line[12:16].strip()
                    element = line[76:78].strip()
                    if not element: 
                        element = ''.join([c for c in atom_name if c.isalpha()])[:1]
                    
                    # 仅保留重原子 (根据你的需求调整)
                    if element.upper() != 'H':
                        x = float(line[30:38])
                        y = float(line[38:46])
                        z = float(line[46:54])
                        coords.append([x, y, z])
                        elements.append(element)
                        atom_lines.append(line)
    except Exception as e:
        print(f"Error reading PDB {pdb_file}: {e}")
        return None, None, None
    return np.array(coords), elements, atom_lines

def load_cube_and_map(cube_file, pdb_file, integration_radius=1.5):
    """(保持不变) 加载 Cube 并计算积分"""
    ref_coords, ref_elements, ref_lines = get_ref_data_from_pdb(pdb_file)
    if ref_coords is None: return None
        
    cp = CubeParser(cube_file)
    integrals = cp.get_carbon_integrals(integration_radius)
    
    # 简单的长度检查
    if len(integrals) != len(ref_coords):
        print(f"[QC Warning] Atom count mismatch! Cube: {len(integrals)}, PDB: {len(ref_coords)}")
        min_len = min(len(integrals), len(ref_coords))
        integrals = integrals[:min_len]; ref_coords = ref_coords[:min_len]

    return {
        "integrals": integrals,
        "coords": ref_coords,
        "elements": ref_elements,
        "pdb_lines": ref_lines,
        "cube_parser": cp,
        "pdb_path": pdb_file
    }

def save_qc_structure(output_pdb_path, qm_data, normalize=True, global_max=None):
    """
    生成 QC PDB
    :param global_max: 如果提供，将使用此值进行归一化（val / global_max）
    """
    integrals = qm_data['integrals']
    original_lines = qm_data['pdb_lines']
    
    display_values = integrals
    
    # 确定归一化分母
    denominator = 1.0
    if normalize:
        if global_max is not None:
            denominator = global_max
        elif len(integrals) > 0:
            denominator = np.max(integrals)
            
        if denominator > 0:
            display_values = integrals / denominator

    with open(output_pdb_path, 'w') as f:
        f.write(f"REMARK   Generated by 1_1_extract_cub_features (QC Tool)\n")
        f.write(f"REMARK   Normalization Reference: {'Global Dopa Max' if global_max else 'Local Max'}\n")
        f.write(f"REMARK   Max Value Used: {denominator:.4f}\n")
        
        for i, line in enumerate(original_lines):
            if i >= len(display_values): break
            val = display_values[i]
            pre = line[:60]
            post = line[66:].rstrip()
            f.write(f"{pre}{val:6.2f}{post}\n")
        f.write("END\n")

def validate_md_mapping(qm_data, target_gro_path, output_path, global_max=1.0):
    """
    验证 MD 结构 (GRO) 是否能与 QM 参考结构 (Ref PDB) 进行拓扑匹配。
    功能：
    1. 自动清洗 GRO 文件的非法元素。
    2. 使用骨架匹配 (Skeleton Match) 忽略键级差异。
    3. 【核心修复】匹配成功后，使用 MDAnalysis 将 QM 积分值写入 B-factor 列并保存。
    """
    try:
        # -----------------------------------------------------------
        # 1. 解析 QM 数据中的 Ref PDB
        # -----------------------------------------------------------
        if isinstance(qm_data, dict) and 'pdb_path' in qm_data:
            ref_mol = Chem.MolFromPDBFile(qm_data['pdb_path'], removeHs=True, sanitize=False)
        else:
            print(f"  [Error] qm_data structure unknown.")
            return False

        if ref_mol is None:
            print("  [Error] Failed to load Ref PDB for mapping.")
            return False
        
        # -----------------------------------------------------------
        # 2. 加载 MD 结构 (GRO) 并转换为 RDKit 可读的 PDB
        # -----------------------------------------------------------
        target_mol = None
        u = None    # MDAnalysis Universe
        sel = None  # MDAnalysis AtomGroup (Ligand)
        
        # A. 尝试直接读取 (如果是 PDB)
        try:
            target_mol = Chem.MolFromPDBFile(target_gro_path, removeHs=True, sanitize=False)
        except:
            pass
            
        # B. 如果直接读取失败且是 GRO，使用 MDAnalysis 转换
        if target_mol is None and target_gro_path.endswith('.gro'):
            tmp_path = None
            try:
                import MDAnalysis as mda
                import tempfile
                import warnings
                import os
                
                # 加载 Universe (屏蔽警告)
                try:
                    with warnings.catch_warnings():
                        warnings.simplefilter("ignore")
                        u = mda.Universe(target_gro_path)
                except Exception as e_mda:
                    print(f"  [Error] MDAnalysis failed to load GRO: {e_mda}")
                    return False

                # [修复] 确保 Universe 具有 'elements' 属性
                if not hasattr(u.atoms, 'elements'):
                    u.add_TopologyAttr('elements')

                # [修复] 智能选择配体
                try:
                    ligand_res = find_ligand(u) # 调用同文件中的辅助函数
                    if ligand_res: sel = ligand_res.atoms
                except: pass
                
                # 兜底选择策略
                if sel is None or len(sel) == 0:
                    sel = u.select_atoms("not (protein or water or resname SOL WAT TIP3 ION NA CL K MG ZN CA)")
                
                if len(sel) == 0:
                    print(f"  [Error] Could not identify any ligand atoms.")
                    return False
                if len(sel) > 500:
                    print(f"  [Error] Selected group has {len(sel)} atoms (likely protein). Skipping.")
                    return False

                # [修复] 元素清洗 (L -> C)
                valid_elems = set(['H', 'C', 'N', 'O', 'S', 'F', 'P', 'CL', 'BR', 'I', 'B', 'SI', 'FE', 'ZN', 'MG', 'CA', 'NA', 'K', 'LI'])
                for atom in sel:
                    original_elem = atom.element.upper()
                    if original_elem not in valid_elems:
                        name = atom.name.upper()
                        # 从原子名猜测元素
                        guess = "".join(filter(str.isalpha, name))
                        if len(guess) > 2: guess = guess[:2]
                        
                        if guess in valid_elems: atom.element = guess
                        elif len(guess) > 0 and guess[0] in valid_elems: atom.element = guess[0]
                        else: atom.element = 'C' # 兜底设为碳

                # [修复] 使用临时文件转换
                with tempfile.NamedTemporaryFile(suffix=".pdb", delete=False) as tmp:
                    tmp_path = tmp.name
                
                with warnings.catch_warnings():
                    warnings.simplefilter("ignore")
                    sel.write(tmp_path)
                
                # RDKit 读取临时 PDB
                target_mol = Chem.MolFromPDBFile(tmp_path, removeHs=True, sanitize=False)
                
            except Exception as e:
                print(f"  [Error] MDAnalysis conversion failed: {e}")
            finally:
                if tmp_path and os.path.exists(tmp_path):
                    try: os.remove(tmp_path)
                    except: pass

        if target_mol is None:
            print("  [Error] Could not load MD structure (Target).")
            return False

        # -----------------------------------------------------------
        # 3. 预处理：强制去氢 & 骨架化
        # -----------------------------------------------------------
        try:
            try:
                ref_mol.UpdatePropertyCache(strict=False)
                target_mol.UpdatePropertyCache(strict=False)
            except: pass
            ref_mol = Chem.RemoveHs(ref_mol, sanitize=False)
            target_mol = Chem.RemoveHs(target_mol, sanitize=False)
        except Exception as e:
            print(f"  [Warning] RemoveHs failed: {e}")

        def get_skeleton(mol):
            m = Chem.Mol(mol)
            for b in m.GetBonds():
                b.SetBondType(Chem.BondType.SINGLE)
                b.SetIsAromatic(False)
            for a in m.GetAtoms():
                a.SetIsAromatic(False)
            return m

        ref_skel = get_skeleton(ref_mol)
        target_skel = get_skeleton(target_mol)

        # -----------------------------------------------------------
        # 4. 执行匹配 & 保存带权重的 PDB
        # -----------------------------------------------------------
        if target_skel.HasSubstructMatch(ref_skel):
            match_indices = target_skel.GetSubstructMatch(ref_skel)
            
            try:
                # 准备积分数据
                integrals = qm_data.get('integrals', [])
                if global_max and global_max > 0:
                    normalized_integrals = integrals / global_max
                else:
                    normalized_integrals = integrals

                # 分支 A: 如果有 MDAnalysis 对象 (u, sel)，用 MDA 保存 (推荐，格式最稳)
                if u is not None and sel is not None:
                    import MDAnalysis as mda
                    # 确保有 tempfactors 属性 (B-factor)
                    if not hasattr(u.atoms, 'tempfactors'):
                        u.add_TopologyAttr('tempfactors')
                    
                    # 初始化权重数组 (全0)
                    b_factors = np.zeros(len(sel))
                    
                    # 填入权重
                    # match_indices[ref_idx] = md_atom_index (在 target_mol/sel 中的索引)
                    for ref_idx, md_idx in enumerate(match_indices):
                        if ref_idx < len(normalized_integrals):
                            b_factors[md_idx] = normalized_integrals[ref_idx]
                    
                    # 赋值并保存
                    sel.tempfactors = b_factors
                    with mda.Writer(output_path, n_atoms=len(sel)) as W:
                        W.write(sel)
                        
                # 分支 B: 如果没有 MDA 对象 (直接读的 PDB)，用 RDKit 保存
                else:
                    for atom in target_mol.GetAtoms():
                        atom.SetDoubleProp("tempFactor", 0.00)
                    for ref_idx, md_idx in enumerate(match_indices):
                        if ref_idx < len(normalized_integrals):
                            val = float(normalized_integrals[ref_idx])
                            target_mol.GetAtomWithIdx(md_idx).SetDoubleProp("tempFactor", val)
                    Chem.MolToPDBFile(target_mol, output_path)

            except Exception as e:
                print(f"  [Warning] Mapping succeeded but failed to save PDB: {e}")
            
            return True
        else:
            print(f"    Ref Heavy Atoms: {ref_mol.GetNumHeavyAtoms()}")
            print(f"    MD  Heavy Atoms: {target_mol.GetNumHeavyAtoms()}")
            return False

    except Exception as e:
        print(f"  [Exception] Mapping process crashed: {e}")
        return False